<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Counting Functions · StatsBase.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="StatsBase.jl logo"/></a><h1>StatsBase.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">StatsBase.jl Documentation</a></li><li><a class="toctext" href="../weights/">Weight Vectors</a></li><li><a class="toctext" href="../means/">Mean Functions</a></li><li><a class="toctext" href="../scalarstats/">Scalar Statistics</a></li><li><a class="toctext" href="../robust/">Robust Statistics</a></li><li><a class="toctext" href="../deviation/">Computing Deviations</a></li><li><a class="toctext" href="../cov/">Scatter Matrix and Covariance</a></li><li class="current"><a class="toctext" href>Counting Functions</a><ul class="internal"><li><a class="toctext" href="#Counting-over-an-Integer-Range-1">Counting over an Integer Range</a></li><li><a class="toctext" href="#Counting-over-arbitrary-distinct-values-1">Counting over arbitrary distinct values</a></li></ul></li><li><a class="toctext" href="../ranking/">Rankings and Rank Correlations</a></li><li><a class="toctext" href="../sampling/">Sampling from Population</a></li><li><a class="toctext" href="../empirical/">Empirical Estimation</a></li><li><a class="toctext" href="../signalcorr/">Correlation Analysis of Signals</a></li><li><a class="toctext" href="../multivariate/">Multivariate Summary Statistics</a></li><li><a class="toctext" href="../misc/">Miscellaneous Functions</a></li><li><a class="toctext" href="../statmodels/">Abstraction for Statistical Models</a></li><li><a class="toctext" href="../transformations/">Data Transformations</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Counting Functions</a></li></ul><a class="edit-page" href="https://github.com/JuliaStats/StatsBase.jl/blob/master/docs/src/counts.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Counting Functions</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Counting-Functions-1" href="#Counting-Functions-1">Counting Functions</a></h1><p>The package provides functions to count the occurrences of distinct values.</p><h2><a class="nav-anchor" id="Counting-over-an-Integer-Range-1" href="#Counting-over-an-Integer-Range-1">Counting over an Integer Range</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.counts" href="#StatsBase.counts"><code>StatsBase.counts</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">counts(x, [wv::AbstractWeights])
counts(x, levels::UnitRange{&lt;:Integer}, [wv::AbstractWeights])
counts(x, k::Integer, [wv::AbstractWeights])</code></pre><p>Count the number of times each value in <code>x</code> occurs. If <code>levels</code> is provided, only values falling in that range will be considered (the others will be ignored without raising an error or a warning). If an integer <code>k</code> is provided, only values in the range <code>1:k</code> will be considered.</p><p>If a weighting vector <code>wv</code> is specified, the sum of the weights is used rather than the raw counts.</p><p>The output is a vector of length <code>length(levels)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/182cb82ec5526aec41603b50e2b05503cdceb799/src/counts.jl#L63-L77">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.proportions" href="#StatsBase.proportions"><code>StatsBase.proportions</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">proportions(x, levels=span(x), [wv::AbstractWeights])</code></pre><p>Return the proportion of values in the range <code>levels</code> that occur in <code>x</code>. Equivalent to <code>counts(x, levels) / length(x)</code>. If a weighting vector <code>wv</code> is specified, the sum of the weights is used rather than the raw counts.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/182cb82ec5526aec41603b50e2b05503cdceb799/src/counts.jl#L90-L96">source</a><div><div><pre><code class="language-none">proportions(x, k::Integer, [wv::AbstractWeights])</code></pre><p>Return the proportion of integers in 1 to <code>k</code> that occur in <code>x</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/182cb82ec5526aec41603b50e2b05503cdceb799/src/counts.jl#L101-L105">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.addcounts!-Tuple{AbstractArray,AbstractArray{T,N} where N where T&lt;:Integer,UnitRange{T} where T&lt;:Integer}" href="#StatsBase.addcounts!-Tuple{AbstractArray,AbstractArray{T,N} where N where T&lt;:Integer,UnitRange{T} where T&lt;:Integer}"><code>StatsBase.addcounts!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">addcounts!(r, x, levels::UnitRange{&lt;:Int}, [wv::AbstractWeights])</code></pre><p>Add the number of occurrences in <code>x</code> of each value in <code>levels</code> to an existing array <code>r</code>. If a weighting vector <code>wv</code> is specified, the sum of weights is used rather than the raw counts.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/182cb82ec5526aec41603b50e2b05503cdceb799/src/counts.jl#L18-L24">source</a></section><h2><a class="nav-anchor" id="Counting-over-arbitrary-distinct-values-1" href="#Counting-over-arbitrary-distinct-values-1">Counting over arbitrary distinct values</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.countmap" href="#StatsBase.countmap"><code>StatsBase.countmap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">countmap(x; alg = :auto)</code></pre><p>Return a dictionary mapping each unique value in <code>x</code> to its number of occurrences.</p><ul><li><p><code>:auto</code> (default): if <code>StatsBase.radixsort_safe(eltype(x)) == true</code> then use                    <code>:radixsort</code>, otherwise use <code>:dict</code>.</p></li><li><p><code>:radixsort</code>:      if <code>radixsort_safe(eltype(x)) == true</code> then use the                    <a href="https://en.wikipedia.org/wiki/Radix_sort">radix sort</a>                    algorithm to sort the input vector which will generally lead to                    shorter running time. However the radix sort algorithm creates a                    copy of the input vector and hence uses more RAM. Choose <code>:dict</code>                    if the amount of available RAM is a limitation.</p></li><li><p><code>:dict</code>:           use <code>Dict</code>-based method which is generally slower but uses less                    RAM and is safe for any data type.</p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/182cb82ec5526aec41603b50e2b05503cdceb799/src/counts.jl#L373-L391">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.proportionmap" href="#StatsBase.proportionmap"><code>StatsBase.proportionmap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">proportionmap(x)</code></pre><p>Return a dictionary mapping each unique value in <code>x</code> to its proportion in <code>x</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/182cb82ec5526aec41603b50e2b05503cdceb799/src/counts.jl#L396-L401">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.addcounts!-Union{Tuple{T}, Tuple{Dict{T,V} where V,AbstractArray{T,N} where N}} where T" href="#StatsBase.addcounts!-Union{Tuple{T}, Tuple{Dict{T,V} where V,AbstractArray{T,N} where N}} where T"><code>StatsBase.addcounts!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">addcounts!(dict, x[, wv]; alg = :auto)</code></pre><p>Add counts based on <code>x</code> to a count map. New entries will be added if new values come up. If a weighting vector <code>wv</code> is specified, the sum of the weights is used rather than the raw counts.</p><p><code>alg</code> can be one of:</p><ul><li><p><code>:auto</code> (default): if <code>StatsBase.radixsort_safe(eltype(x)) == true</code> then use                    <code>:radixsort</code>, otherwise use <code>:dict</code>.</p></li><li><p><code>:radixsort</code>:      if <code>radixsort_safe(eltype(x)) == true</code> then use the                    <a href="https://en.wikipedia.org/wiki/Radix_sort">radix sort</a>                    algorithm to sort the input vector which will generally lead to                    shorter running time. However the radix sort algorithm creates a                    copy of the input vector and hence uses more RAM. Choose <code>:dict</code>                    if the amount of available RAM is a limitation.</p></li><li><p><code>:dict</code>:           use <code>Dict</code>-based method which is generally slower but uses less                    RAM and is safe for any data type.</p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/182cb82ec5526aec41603b50e2b05503cdceb799/src/counts.jl#L239-L259">source</a></section><footer><hr/><a class="previous" href="../cov/"><span class="direction">Previous</span><span class="title">Scatter Matrix and Covariance</span></a><a class="next" href="../ranking/"><span class="direction">Next</span><span class="title">Rankings and Rank Correlations</span></a></footer></article></body></html>
