<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Sampling from Population · StatsBase.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="StatsBase.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">StatsBase.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">StatsBase.jl Documentation</a></li><li><a class="tocitem" href="../weights/">Weight Vectors</a></li><li><a class="tocitem" href="../scalarstats/">Scalar Statistics</a></li><li><a class="tocitem" href="../robust/">Robust Statistics</a></li><li><a class="tocitem" href="../deviation/">Computing Deviations</a></li><li><a class="tocitem" href="../cov/">Scatter Matrix and Covariance</a></li><li><a class="tocitem" href="../counts/">Counting Functions</a></li><li><a class="tocitem" href="../ranking/">Rankings and Rank Correlations</a></li><li class="is-active"><a class="tocitem" href>Sampling from Population</a><ul class="internal"><li><a class="tocitem" href="#Sampling-API-1"><span>Sampling API</span></a></li><li><a class="tocitem" href="#Algorithms-1"><span>Algorithms</span></a></li></ul></li><li><a class="tocitem" href="../empirical/">Empirical Estimation</a></li><li><a class="tocitem" href="../signalcorr/">Correlation Analysis of Signals</a></li><li><a class="tocitem" href="../multivariate/">Multivariate Summary Statistics</a></li><li><a class="tocitem" href="../misc/">Miscellaneous Functions</a></li><li><a class="tocitem" href="../statmodels/">Abstraction for Statistical Models</a></li><li><a class="tocitem" href="../transformations/">Data Transformations</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Sampling from Population</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Sampling from Population</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaStats/StatsBase.jl/blob/master/docs/src/sampling.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Sampling-from-Population-1"><a class="docs-heading-anchor" href="#Sampling-from-Population-1">Sampling from Population</a><a class="docs-heading-anchor-permalink" href="#Sampling-from-Population-1" title="Permalink"></a></h1><h2 id="Sampling-API-1"><a class="docs-heading-anchor" href="#Sampling-API-1">Sampling API</a><a class="docs-heading-anchor-permalink" href="#Sampling-API-1" title="Permalink"></a></h2><p>The package provides functions for sampling from a given population (with or without replacement).</p><article class="docstring"><header><a class="docstring-binding" id="StatsBase.sample" href="#StatsBase.sample"><code>StatsBase.sample</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sample([rng], a, [wv::AbstractWeights])</code></pre><p>Select a single random element of <code>a</code>. Sampling probabilities are proportional to the weights given in <code>wv</code>, if provided.</p><p>Optionally specify a random number generator <code>rng</code> as the first argument (defaults to <code>Random.GLOBAL_RNG</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/5c011db56740a4a1e6b0f8302484f3114f228f4d/src/sampling.jl#L422-L430">source</a></section><section><div><pre><code class="language-none">sample([rng], a, [wv::AbstractWeights], n::Integer; replace=true, ordered=false)</code></pre><p>Select a random, optionally weighted sample of size <code>n</code> from an array <code>a</code> using a polyalgorithm. Sampling probabilities are proportional to the weights given in <code>wv</code>, if provided. <code>replace</code> dictates whether sampling is performed with replacement. <code>ordered</code> dictates whether an ordered sample (also called a sequential sample, i.e. a sample where items appear in the same order as in <code>a</code>) should be taken.</p><p>Optionally specify a random number generator <code>rng</code> as the first argument (defaults to <code>Random.GLOBAL_RNG</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/5c011db56740a4a1e6b0f8302484f3114f228f4d/src/sampling.jl#L491-L503">source</a></section><section><div><pre><code class="language-none">sample([rng], a, [wv::AbstractWeights], dims::Dims; replace=true, ordered=false)</code></pre><p>Select a random, optionally weighted sample from an array <code>a</code> specifying the dimensions <code>dims</code> of the output array. Sampling probabilities are proportional to the weights given in <code>wv</code>, if provided. <code>replace</code> dictates whether sampling is performed with replacement. <code>ordered</code> dictates whether an ordered sample (also called a sequential sample, i.e. a sample where items appear in the same order as in <code>a</code>) should be taken.</p><p>Optionally specify a random number generator <code>rng</code> as the first argument (defaults to <code>Random.GLOBAL_RNG</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/5c011db56740a4a1e6b0f8302484f3114f228f4d/src/sampling.jl#L512-L524">source</a></section><section><div><pre><code class="language-none">sample([rng], wv::AbstractWeights)</code></pre><p>Select a single random integer in <code>1:length(wv)</code> with probabilities proportional to the weights given in <code>wv</code>.</p><p>Optionally specify a random number generator <code>rng</code> as the first argument (defaults to <code>Random.GLOBAL_RNG</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/5c011db56740a4a1e6b0f8302484f3114f228f4d/src/sampling.jl#L538-L546">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.sample!" href="#StatsBase.sample!"><code>StatsBase.sample!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sample!([rng], a, [wv::AbstractWeights], x; replace=true, ordered=false)</code></pre><p>Draw a random sample of <code>length(x)</code> elements from an array <code>a</code> and store the result in <code>x</code>. A polyalgorithm is used for sampling. Sampling probabilities are proportional to the weights given in <code>wv</code>, if provided. <code>replace</code> dictates whether sampling is performed with replacement. <code>ordered</code> dictates whether an ordered sample (also called a sequential sample, i.e. a sample where items appear in the same order as in <code>a</code>) should be taken.</p><p>Optionally specify a random number generator <code>rng</code> as the first argument (defaults to <code>Random.GLOBAL_RNG</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/5c011db56740a4a1e6b0f8302484f3114f228f4d/src/sampling.jl#L435-L448">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.wsample" href="#StatsBase.wsample"><code>StatsBase.wsample</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">wsample([rng], [a], w)</code></pre><p>Select a weighted random sample of size 1 from <code>a</code> with probabilities proportional to the weights given in <code>w</code>. If <code>a</code> is not present, select a random weight from <code>w</code>.</p><p>Optionally specify a random number generator <code>rng</code> as the first argument (defaults to <code>Random.GLOBAL_RNG</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/5c011db56740a4a1e6b0f8302484f3114f228f4d/src/sampling.jl#L963-L971">source</a></section><section><div><pre><code class="language-none">wsample([rng], [a], w, n::Integer; replace=true, ordered=false)</code></pre><p>Select a weighted random sample of size <code>n</code> from <code>a</code> with probabilities proportional to the weights given in <code>w</code> if <code>a</code> is present, otherwise select a random sample of size <code>n</code> of the weights given in <code>w</code>. <code>replace</code> dictates whether sampling is performed with replacement. <code>ordered</code> dictates whether an ordered sample (also called a sequential sample, i.e. a sample where items appear in the same order as in <code>a</code>) should be taken.</p><p>Optionally specify a random number generator <code>rng</code> as the first argument (defaults to <code>Random.GLOBAL_RNG</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/5c011db56740a4a1e6b0f8302484f3114f228f4d/src/sampling.jl#L978-L990">source</a></section><section><div><pre><code class="language-none">wsample([rng], [a], w, dims::Dims; replace=true, ordered=false)</code></pre><p>Select a weighted random sample from <code>a</code> with probabilities proportional to the weights given in <code>w</code> if <code>a</code> is present, otherwise select a random sample of size <code>n</code> of the weights given in <code>w</code>. The dimensions of the output are given by <code>dims</code>.</p><p>Optionally specify a random number generator <code>rng</code> as the first argument (defaults to <code>Random.GLOBAL_RNG</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/5c011db56740a4a1e6b0f8302484f3114f228f4d/src/sampling.jl#L998-L1007">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.wsample!" href="#StatsBase.wsample!"><code>StatsBase.wsample!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">wsample!([rng], a, w, x; replace=true, ordered=false)</code></pre><p>Select a weighted sample from an array <code>a</code> and store the result in <code>x</code>. Sampling probabilities are proportional to the weights given in <code>w</code>. <code>replace</code> dictates whether sampling is performed with replacement. <code>ordered</code> dictates whether an ordered sample (also called a sequential sample, i.e. a sample where items appear in the same order as in <code>a</code>) should be taken.</p><p>Optionally specify a random number generator <code>rng</code> as the first argument (defaults to <code>Random.GLOBAL_RNG</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/5c011db56740a4a1e6b0f8302484f3114f228f4d/src/sampling.jl#L944-L955">source</a></section></article><h2 id="Algorithms-1"><a class="docs-heading-anchor" href="#Algorithms-1">Algorithms</a><a class="docs-heading-anchor-permalink" href="#Algorithms-1" title="Permalink"></a></h2><p>Internally, this package implements multiple algorithms, and the <code>sample</code> (and <code>sample!</code>) methods integrate them into a poly-algorithm, which chooses a specific algorithm based on inputs.</p><p>Note that the choices made in <code>sample</code> are decided based on extensive benchmarking (see <code>perf/sampling.jl</code> and <code>perf/wsampling.jl</code>). It performs reasonably fast for most cases. That being said, if you know that a certain algorithm is particularly suitable for your context, directly calling an internal algorithm function might be slightly more efficient.</p><p>Here are a list of algorithms implemented in the package. The functions below are not exported (one can still import them from StatsBase via <code>using</code> though).</p><h3 id="Notations-1"><a class="docs-heading-anchor" href="#Notations-1">Notations</a><a class="docs-heading-anchor-permalink" href="#Notations-1" title="Permalink"></a></h3><ul><li><code>a</code>: source array representing the population</li><li><code>x</code>: the destination array</li><li><code>wv</code>: the weight vector (of type <code>AbstractWeights</code>), for weighted sampling</li><li><code>n</code>: the length of <code>a</code></li><li><code>k</code>: the length of <code>x</code>. For sampling without replacement, <code>k</code> must not exceed <code>n</code>.</li><li><code>rng</code>: optional random number generator (defaults to <code>Random.GLOBAL_RNG</code>)</li></ul><p>All following functions write results to <code>x</code> (pre-allocated) and return <code>x</code>.</p><h3 id="Sampling-Algorithms-(Non-Weighted)-1"><a class="docs-heading-anchor" href="#Sampling-Algorithms-(Non-Weighted)-1">Sampling Algorithms (Non-Weighted)</a><a class="docs-heading-anchor-permalink" href="#Sampling-Algorithms-(Non-Weighted)-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="StatsBase.direct_sample!-Tuple{AbstractRNG, AbstractArray, AbstractArray}" href="#StatsBase.direct_sample!-Tuple{AbstractRNG, AbstractArray, AbstractArray}"><code>StatsBase.direct_sample!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">direct_sample!([rng], a::AbstractArray, x::AbstractArray)</code></pre><p>Direct sampling: for each <code>j</code> in <code>1:k</code>, randomly pick <code>i</code> from <code>1:n</code>, and set <code>x[j] = a[i]</code>, with <code>n=length(a)</code> and <code>k=length(x)</code>.</p><p>This algorithm consumes <code>k</code> random numbers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/5c011db56740a4a1e6b0f8302484f3114f228f4d/src/sampling.jl#L28-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.samplepair" href="#StatsBase.samplepair"><code>StatsBase.samplepair</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">samplepair([rng], n)</code></pre><p>Draw a pair of distinct integers between 1 and <code>n</code> without replacement.</p><p>Optionally specify a random number generator <code>rng</code> as the first argument (defaults to <code>Random.GLOBAL_RNG</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/5c011db56740a4a1e6b0f8302484f3114f228f4d/src/sampling.jl#L90-L97">source</a></section><section><div><pre><code class="language-none">samplepair([rng], a)</code></pre><p>Draw a pair of distinct elements from the array <code>a</code> without replacement.</p><p>Optionally specify a random number generator <code>rng</code> as the first argument (defaults to <code>Random.GLOBAL_RNG</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/5c011db56740a4a1e6b0f8302484f3114f228f4d/src/sampling.jl#L105-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.knuths_sample!" href="#StatsBase.knuths_sample!"><code>StatsBase.knuths_sample!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">knuths_sample!([rng], a, x)</code></pre><p><em>Knuth&#39;s Algorithm S</em> for random sampling without replacement.</p><p>Reference: D. Knuth. <em>The Art of Computer Programming</em>. Vol 2, 3.4.2, p.142.</p><p>This algorithm consumes <code>length(a)</code> random numbers. It requires no additional memory space. Suitable for the case where memory is tight.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/5c011db56740a4a1e6b0f8302484f3114f228f4d/src/sampling.jl#L121-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.fisher_yates_sample!" href="#StatsBase.fisher_yates_sample!"><code>StatsBase.fisher_yates_sample!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fisher_yates_sample!([rng], a::AbstractArray, x::AbstractArray)</code></pre><p>Fisher-Yates shuffling (with early termination).</p><p>Pseudo-code:</p><pre><code class="language-none">n = length(a)
k = length(x)

# Create an array of the indices
inds = collect(1:n)

for i = 1:k
    # swap element `i` with another random element in inds[i:n]
    # set element `i` in `x`
end</code></pre><p>This algorithm consumes <code>k=length(x)</code> random numbers. It uses an integer array of length <code>n=length(a)</code> internally to maintain the shuffled indices. It is considerably faster than Knuth&#39;s algorithm especially when <code>n</code> is greater than <code>k</code>. It is <span>$O(n)$</span> for initialization, plus <span>$O(k)$</span> for random shuffling</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/5c011db56740a4a1e6b0f8302484f3114f228f4d/src/sampling.jl#L164-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.self_avoid_sample!" href="#StatsBase.self_avoid_sample!"><code>StatsBase.self_avoid_sample!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">self_avoid_sample!([rng], a::AbstractArray, x::AbstractArray)</code></pre><p>Self-avoid sampling: use a set to maintain the index that has been sampled. Each time draw a new index, if the index has already been sampled, redraw until it draws an unsampled one.</p><p>This algorithm consumes about (or slightly more than) <code>k=length(x)</code> random numbers, and requires <span>$O(k)$</span> memory to store the set of sampled indices. Very fast when <span>$n &gt;&gt; k$</span>, with <code>n=length(a)</code>.</p><p>However, if <code>k</code> is large and approaches <span>$n$</span>, the rejection rate would increase drastically, resulting in poorer performance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/5c011db56740a4a1e6b0f8302484f3114f228f4d/src/sampling.jl#L210-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.seqsample_a!" href="#StatsBase.seqsample_a!"><code>StatsBase.seqsample_a!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">seqsample_a!([rng], a::AbstractArray, x::AbstractArray)</code></pre><p>Random subsequence sampling using algorithm A described in the following paper (page 714): Jeffrey Scott Vitter. &quot;Faster Methods for Random Sampling&quot;. Communications of the ACM, 27 (7), July 1984.</p><p>This algorithm consumes <span>$O(n)$</span> random numbers, with <code>n=length(a)</code>. The outputs are ordered.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/5c011db56740a4a1e6b0f8302484f3114f228f4d/src/sampling.jl#L252-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.seqsample_c!" href="#StatsBase.seqsample_c!"><code>StatsBase.seqsample_c!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">seqsample_c!([rng], a::AbstractArray, x::AbstractArray)</code></pre><p>Random subsequence sampling using algorithm C described in the following paper (page 715): Jeffrey Scott Vitter. &quot;Faster Methods for Random Sampling&quot;. Communications of the ACM, 27 (7), July 1984.</p><p>This algorithm consumes <span>$O(k^2)$</span> random numbers, with <code>k=length(x)</code>. The outputs are ordered.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/5c011db56740a4a1e6b0f8302484f3114f228f4d/src/sampling.jl#L290-L299">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.seqsample_d!" href="#StatsBase.seqsample_d!"><code>StatsBase.seqsample_d!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">seqsample_d!([rng], a::AbstractArray, x::AbstractArray)</code></pre><p>Random subsequence sampling using algorithm D described in the following paper (page 716-17): Jeffrey Scott Vitter. &quot;Faster Methods for Random Sampling&quot;. Communications of the ACM, 27 (7), July 1984.</p><p>This algorithm consumes <span>$O(k)$</span> random numbers, with <code>k=length(x)</code>. The outputs are ordered.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/5c011db56740a4a1e6b0f8302484f3114f228f4d/src/sampling.jl#L332-L341">source</a></section></article><h3 id="Weighted-Sampling-Algorithms-1"><a class="docs-heading-anchor" href="#Weighted-Sampling-Algorithms-1">Weighted Sampling Algorithms</a><a class="docs-heading-anchor-permalink" href="#Weighted-Sampling-Algorithms-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="StatsBase.direct_sample!-Tuple{AbstractRNG, AbstractArray, AbstractWeights, AbstractArray}" href="#StatsBase.direct_sample!-Tuple{AbstractRNG, AbstractArray, AbstractWeights, AbstractArray}"><code>StatsBase.direct_sample!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">direct_sample!([rng], a::AbstractArray, wv::AbstractWeights, x::AbstractArray)</code></pre><p>Direct sampling.</p><p>Draw each sample by scanning the weight vector.</p><p>Noting <code>k=length(x)</code> and <code>n=length(a)</code>, this algorithm:</p><ul><li>consumes <code>k</code> random numbers</li><li>has time complexity <span>$O(n k)$</span>, as scanning the weight vector each time takes <span>$O(n)$</span></li><li>requires no additional memory space.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/5c011db56740a4a1e6b0f8302484f3114f228f4d/src/sampling.jl#L563-L574">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.alias_sample!" href="#StatsBase.alias_sample!"><code>StatsBase.alias_sample!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">alias_sample!([rng], a::AbstractArray, wv::AbstractWeights, x::AbstractArray)</code></pre><p>Alias method.</p><p>Build an alias table, and sample therefrom.</p><p>Reference: Walker, A. J. &quot;An Efficient Method for Generating Discrete Random Variables with General Distributions.&quot; <em>ACM Transactions on Mathematical Software</em> 3 (3): 253, 1977.</p><p>Noting <code>k=length(x)</code> and <code>n=length(a)</code>, this algorithm takes <span>$O(n \log n)$</span> time for building the alias table, and then <span>$O(1)$</span> to draw each sample. It consumes <span>$2 k$</span> random numbers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/5c011db56740a4a1e6b0f8302484f3114f228f4d/src/sampling.jl#L646-L658">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.naive_wsample_norep!" href="#StatsBase.naive_wsample_norep!"><code>StatsBase.naive_wsample_norep!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">naive_wsample_norep!([rng], a::AbstractArray, wv::AbstractWeights, x::AbstractArray)</code></pre><p>Naive implementation of weighted sampling without replacement.</p><p>It makes a copy of the weight vector at initialization, and sets the weight to zero when the corresponding sample is picked.</p><p>Noting <code>k=length(x)</code> and <code>n=length(a)</code>, this algorithm consumes <span>$O(k)$</span> random numbers, and has overall time complexity <span>$O(n k)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/5c011db56740a4a1e6b0f8302484f3114f228f4d/src/sampling.jl#L679-L689">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.efraimidis_a_wsample_norep!" href="#StatsBase.efraimidis_a_wsample_norep!"><code>StatsBase.efraimidis_a_wsample_norep!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">efraimidis_a_wsample_norep!([rng], a::AbstractArray, wv::AbstractWeights, x::AbstractArray)</code></pre><p>Weighted sampling without replacement using Efraimidis-Spirakis A algorithm.</p><p>Reference: Efraimidis, P. S., Spirakis, P. G. &quot;Weighted random sampling with a reservoir.&quot; <em>Information Processing Letters</em>, 97 (5), 181-185, 2006. doi:10.1016/j.ipl.2005.11.003.</p><p>Noting <code>k=length(x)</code> and <code>n=length(a)</code>, this algorithm takes <span>$O(n + k \log k)$</span> processing time to draw <span>$k$</span> elements. It consumes <span>$n$</span> random numbers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/5c011db56740a4a1e6b0f8302484f3114f228f4d/src/sampling.jl#L719-L729">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.efraimidis_ares_wsample_norep!" href="#StatsBase.efraimidis_ares_wsample_norep!"><code>StatsBase.efraimidis_ares_wsample_norep!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">efraimidis_ares_wsample_norep!([rng], a::AbstractArray, wv::AbstractWeights, x::AbstractArray)</code></pre><p>Implementation of weighted sampling without replacement using Efraimidis-Spirakis A-Res algorithm.</p><p>Reference: Efraimidis, P. S., Spirakis, P. G. &quot;Weighted random sampling with a reservoir.&quot; <em>Information Processing Letters</em>, 97 (5), 181-185, 2006. doi:10.1016/j.ipl.2005.11.003.</p><p>Noting <code>k=length(x)</code> and <code>n=length(a)</code>, this algorithm takes <span>$O(k \log(k) \log(n / k))$</span> processing time to draw <span>$k$</span> elements. It consumes <span>$n$</span> random numbers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/5c011db56740a4a1e6b0f8302484f3114f228f4d/src/sampling.jl#L754-L764">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ranking/">« Rankings and Rank Correlations</a><a class="docs-footer-nextpage" href="../empirical/">Empirical Estimation »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 31 March 2022 07:45">Thursday 31 March 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
