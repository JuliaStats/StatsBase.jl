<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Sampling from Population · StatsBase.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="StatsBase.jl logo"/></a><h1>StatsBase.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">StatsBase.jl Documentation</a></li><li><a class="toctext" href="../weights/">Weight Vectors</a></li><li><a class="toctext" href="../means/">Mean Functions</a></li><li><a class="toctext" href="../scalarstats/">Scalar Statistics</a></li><li><a class="toctext" href="../robust/">Robust Statistics</a></li><li><a class="toctext" href="../deviation/">Computing Deviations</a></li><li><a class="toctext" href="../cov/">Scatter Matrix and Covariance</a></li><li><a class="toctext" href="../counts/">Counting Functions</a></li><li><a class="toctext" href="../ranking/">Rankings and Rank Correlations</a></li><li class="current"><a class="toctext" href>Sampling from Population</a><ul class="internal"><li><a class="toctext" href="#Sampling-API-1">Sampling API</a></li><li><a class="toctext" href="#Algorithms-1">Algorithms</a></li></ul></li><li><a class="toctext" href="../empirical/">Empirical Estimation</a></li><li><a class="toctext" href="../signalcorr/">Correlation Analysis of Signals</a></li><li><a class="toctext" href="../multivariate/">Multivariate Summary Statistics</a></li><li><a class="toctext" href="../misc/">Miscellaneous Functions</a></li><li><a class="toctext" href="../statmodels/">Abstraction for Statistical Models</a></li><li><a class="toctext" href="../transformations/">Data Transformations</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Sampling from Population</a></li></ul><a class="edit-page" href="https://github.com/JuliaStats/StatsBase.jl/blob/master/docs/src/sampling.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Sampling from Population</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Sampling-from-Population-1" href="#Sampling-from-Population-1">Sampling from Population</a></h1><h2><a class="nav-anchor" id="Sampling-API-1" href="#Sampling-API-1">Sampling API</a></h2><p>The package provides functions for sampling from a given population (with or without replacement).</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.sample" href="#StatsBase.sample"><code>StatsBase.sample</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sample([rng], a, [wv::AbstractWeights])</code></pre><p>Select a single random element of <code>a</code>. Sampling probabilities are proportional to the weights given in <code>wv</code>, if provided.</p><p>Optionally specify a random number generator <code>rng</code> as the first argument (defaults to <code>Random.GLOBAL_RNG</code>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/8f422bdcf0d1c4763372e35df7f1f310c7201a40/src/sampling.jl#L293-L301">source</a><div><div><pre><code class="language-none">sample([rng], a, [wv::AbstractWeights], n::Integer; replace=true, ordered=false)</code></pre><p>Select a random, optionally weighted sample of size <code>n</code> from an array <code>a</code> using a polyalgorithm. Sampling probabilities are proportional to the weights given in <code>wv</code>, if provided. <code>replace</code> dictates whether sampling is performed with replacement and <code>order</code> dictates whether an ordered sample, also called a sequential sample, should be taken.</p><p>Optionally specify a random number generator <code>rng</code> as the first argument (defaults to <code>Random.GLOBAL_RNG</code>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/8f422bdcf0d1c4763372e35df7f1f310c7201a40/src/sampling.jl#L359-L370">source</a><div><div><pre><code class="language-none">sample([rng], a, [wv::AbstractWeights], dims::Dims; replace=true, ordered=false)</code></pre><p>Select a random, optionally weighted sample from an array <code>a</code> specifying the dimensions <code>dims</code> of the output array. Sampling probabilities are proportional to the weights given in <code>wv</code>, if provided. <code>replace</code> dictates whether sampling is performed with replacement and <code>order</code> dictates whether an ordered sample, also called a sequential sample, should be taken.</p><p>Optionally specify a random number generator <code>rng</code> as the first argument (defaults to <code>Random.GLOBAL_RNG</code>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/8f422bdcf0d1c4763372e35df7f1f310c7201a40/src/sampling.jl#L379-L390">source</a><div><div><pre><code class="language-none">sample([rng], wv::AbstractWeights)</code></pre><p>Select a single random integer in <code>1:length(wv)</code> with probabilities proportional to the weights given in <code>wv</code>.</p><p>Optionally specify a random number generator <code>rng</code> as the first argument (defaults to <code>Random.GLOBAL_RNG</code>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/8f422bdcf0d1c4763372e35df7f1f310c7201a40/src/sampling.jl#L404-L412">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.sample!" href="#StatsBase.sample!"><code>StatsBase.sample!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sample!([rng], a, [wv::AbstractWeights], x; replace=true, ordered=false)</code></pre><p>Draw a random sample of <code>length(x)</code> elements from an array <code>a</code> and store the result in <code>x</code>. A polyalgorithm is used for sampling. Sampling probabilities are proportional to the weights given in <code>wv</code>, if provided. <code>replace</code> dictates whether sampling is performed with replacement and <code>order</code> dictates whether an ordered sample, also called a sequential sample, should be taken.</p><p>Optionally specify a random number generator <code>rng</code> as the first argument (defaults to <code>Random.GLOBAL_RNG</code>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/8f422bdcf0d1c4763372e35df7f1f310c7201a40/src/sampling.jl#L306-L318">source</a></section><h2><a class="nav-anchor" id="Algorithms-1" href="#Algorithms-1">Algorithms</a></h2><p>Internally, this package implements multiple algorithms, and the <code>sample</code> (and <code>sample!</code>) methods integrate them into a poly-algorithm, which chooses a specific algorithm based on inputs.</p><p>Note that the choices made in <code>sample</code> are decided based on extensive benchmarking (see <code>perf/sampling.jl</code> and <code>perf/wsampling.jl</code>). It performs reasonably fast for most cases. That being said, if you know that a certain algorithm is particularly suitable for your context, directly calling an internal algorithm function might be slightly more efficient.</p><p>Here are a list of algorithms implemented in the package. The functions below are not exported (one can still import them from StatsBase via <code>using</code> though).</p><h3><a class="nav-anchor" id="Notations-1" href="#Notations-1">Notations</a></h3><ul><li><code>a</code>: source array representing the population</li><li><code>x</code>: the destination array</li><li><code>wv</code>: the weight vector (of type <code>AbstractWeights</code>), for weighted sampling</li><li><code>n</code>: the length of <code>a</code></li><li><code>k</code>: the length of <code>x</code>. For sampling without replacement, <code>k</code> must not exceed <code>n</code>.</li><li><code>rng</code>: optional random number generator (defaults to <code>Random.GLOBAL_RNG</code>)</li></ul><p>All following functions write results to <code>x</code> (pre-allocated) and return <code>x</code>.</p><h3><a class="nav-anchor" id="Sampling-Algorithms-(Non-Weighted)-1" href="#Sampling-Algorithms-(Non-Weighted)-1">Sampling Algorithms (Non-Weighted)</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.direct_sample!-Tuple{AbstractRNG,AbstractArray,AbstractArray}" href="#StatsBase.direct_sample!-Tuple{AbstractRNG,AbstractArray,AbstractArray}"><code>StatsBase.direct_sample!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">direct_sample!([rng], a::AbstractArray, x::AbstractArray)</code></pre><p>Direct sampling: for each <code>j</code> in <code>1:k</code>, randomly pick <code>i</code> from <code>1:n</code>, and set <code>x[j] = a[i]</code>, with <code>n=length(a)</code> and <code>k=length(x)</code>.</p><p>This algorithm consumes <code>k</code> random numbers.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/8f422bdcf0d1c4763372e35df7f1f310c7201a40/src/sampling.jl#L28-L35">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.samplepair" href="#StatsBase.samplepair"><code>StatsBase.samplepair</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">samplepair([rng], n)</code></pre><p>Draw a pair of distinct integers between 1 and <code>n</code> without replacement.</p><p>Optionally specify a random number generator <code>rng</code> as the first argument (defaults to <code>Random.GLOBAL_RNG</code>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/8f422bdcf0d1c4763372e35df7f1f310c7201a40/src/sampling.jl#L47-L54">source</a><div><div><pre><code class="language-none">samplepair([rng], a)</code></pre><p>Draw a pair of distinct elements from the array <code>a</code> without replacement.</p><p>Optionally specify a random number generator <code>rng</code> as the first argument (defaults to <code>Random.GLOBAL_RNG</code>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/8f422bdcf0d1c4763372e35df7f1f310c7201a40/src/sampling.jl#L62-L69">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.knuths_sample!" href="#StatsBase.knuths_sample!"><code>StatsBase.knuths_sample!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">knuths_sample!([rng], a, x)</code></pre><p><em>Knuth&#39;s Algorithm S</em> for random sampling without replacement.</p><p>Reference: D. Knuth. <em>The Art of Computer Programming</em>. Vol 2, 3.4.2, p.142.</p><p>This algorithm consumes <code>length(a)</code> random numbers. It requires no additional memory space. Suitable for the case where memory is tight.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/8f422bdcf0d1c4763372e35df7f1f310c7201a40/src/sampling.jl#L78-L87">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.fisher_yates_sample!" href="#StatsBase.fisher_yates_sample!"><code>StatsBase.fisher_yates_sample!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">fisher_yates_sample!([rng], a::AbstractArray, x::AbstractArray)</code></pre><p>Fisher-Yates shuffling (with early termination).</p><p>Pseudo-code:</p><pre><code class="language-none">n = length(a)
k = length(x)

# Create an array of the indices
inds = collect(1:n)

for i = 1:k
    # swap element `i` with another random element in inds[i:n]
    # set element `i` in `x`
end</code></pre><p>This algorithm consumes <code>k=length(x)</code> random numbers. It uses an integer array of length <code>n=length(a)</code> internally to maintain the shuffled indices. It is considerably faster than Knuth&#39;s algorithm especially when <code>n</code> is greater than <code>k</code>. It is <span>$O(n)$</span> for initialization, plus <span>$O(k)$</span> for random shuffling</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/8f422bdcf0d1c4763372e35df7f1f310c7201a40/src/sampling.jl#L121-L144">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.self_avoid_sample!" href="#StatsBase.self_avoid_sample!"><code>StatsBase.self_avoid_sample!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">self_avoid_sample!([rng], a::AbstractArray, x::AbstractArray)</code></pre><p>Self-avoid sampling: use a set to maintain the index that has been sampled. Each time draw a new index, if the index has already been sampled, redraw until it draws an unsampled one.</p><p>This algorithm consumes about (or slightly more than) <code>k=length(x)</code> random numbers, and requires <span>$O(k)$</span> memory to store the set of sampled indices. Very fast when <span>$n &gt;&gt; k$</span>, with <code>n=length(a)</code>.</p><p>However, if <code>k</code> is large and approaches <span>$n$</span>, the rejection rate would increase drastically, resulting in poorer performance.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/8f422bdcf0d1c4763372e35df7f1f310c7201a40/src/sampling.jl#L167-L180">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.seqsample_a!" href="#StatsBase.seqsample_a!"><code>StatsBase.seqsample_a!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">seqsample_a!([rng], a::AbstractArray, x::AbstractArray)</code></pre><p>Random subsequence sampling using algorithm A described in the following paper (page 714): Jeffrey Scott Vitter. &quot;Faster Methods for Random Sampling&quot;. Communications of the ACM, 27 (7), July 1984.</p><p>This algorithm consumes <span>$O(n)$</span> random numbers, with <code>n=length(a)</code>. The outputs are ordered.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/8f422bdcf0d1c4763372e35df7f1f310c7201a40/src/sampling.jl#L209-L218">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.seqsample_c!" href="#StatsBase.seqsample_c!"><code>StatsBase.seqsample_c!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">seqsample_c!([rng], a::AbstractArray, x::AbstractArray)</code></pre><p>Random subsequence sampling using algorithm C described in the following paper (page 715): Jeffrey Scott Vitter. &quot;Faster Methods for Random Sampling&quot;. Communications of the ACM, 27 (7), July 1984.</p><p>This algorithm consumes <span>$O(k^2)$</span> random numbers, with <code>k=length(x)</code>. The outputs are ordered.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/8f422bdcf0d1c4763372e35df7f1f310c7201a40/src/sampling.jl#L247-L256">source</a></section><h3><a class="nav-anchor" id="Weighted-Sampling-Algorithms-1" href="#Weighted-Sampling-Algorithms-1">Weighted Sampling Algorithms</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.direct_sample!-Tuple{AbstractRNG,AbstractArray,AbstractWeights,AbstractArray}" href="#StatsBase.direct_sample!-Tuple{AbstractRNG,AbstractArray,AbstractWeights,AbstractArray}"><code>StatsBase.direct_sample!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">direct_sample!([rng], a::AbstractArray, wv::AbstractWeights, x::AbstractArray)</code></pre><p>Direct sampling.</p><p>Draw each sample by scanning the weight vector.</p><p>Noting <code>k=length(x)</code> and <code>n=length(a)</code>, this algorithm:</p><ul><li>consumes <code>k</code> random numbers</li><li>has time complexity <span>$O(n k)$</span>, as scanning the weight vector each time takes <span>$O(n)$</span></li><li>requires no additional memory space.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/8f422bdcf0d1c4763372e35df7f1f310c7201a40/src/sampling.jl#L430-L441">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.alias_sample!" href="#StatsBase.alias_sample!"><code>StatsBase.alias_sample!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">alias_sample!([rng], a::AbstractArray, wv::AbstractWeights, x::AbstractArray)</code></pre><p>Alias method.</p><p>Build an alias table, and sample therefrom.</p><p>Reference: Walker, A. J. &quot;An Efficient Method for Generating Discrete Random Variables with General Distributions.&quot; <em>ACM Transactions on Mathematical Software</em> 3 (3): 253, 1977.</p><p>Noting <code>k=length(x)</code> and <code>n=length(a)</code>, this algorithm takes <span>$O(n \log n)$</span> time for building the alias table, and then <span>$O(1)$</span> to draw each sample. It consumes <span>$2 k$</span> random numbers.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/8f422bdcf0d1c4763372e35df7f1f310c7201a40/src/sampling.jl#L513-L525">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.naive_wsample_norep!" href="#StatsBase.naive_wsample_norep!"><code>StatsBase.naive_wsample_norep!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">naive_wsample_norep!([rng], a::AbstractArray, wv::AbstractWeights, x::AbstractArray)</code></pre><p>Naive implementation of weighted sampling without replacement.</p><p>It makes a copy of the weight vector at initialization, and sets the weight to zero when the corresponding sample is picked.</p><p>Noting <code>k=length(x)</code> and <code>n=length(a)</code>, this algorithm consumes <span>$O(k)$</span> random numbers, and has overall time complexity <span>$O(n k)$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/8f422bdcf0d1c4763372e35df7f1f310c7201a40/src/sampling.jl#L546-L556">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.efraimidis_a_wsample_norep!" href="#StatsBase.efraimidis_a_wsample_norep!"><code>StatsBase.efraimidis_a_wsample_norep!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">efraimidis_a_wsample_norep!([rng], a::AbstractArray, wv::AbstractWeights, x::AbstractArray)</code></pre><p>Weighted sampling without replacement using Efraimidis-Spirakis A algorithm.</p><p>Reference: Efraimidis, P. S., Spirakis, P. G. &quot;Weighted random sampling with a reservoir.&quot; <em>Information Processing Letters</em>, 97 (5), 181-185, 2006. doi:10.1016/j.ipl.2005.11.003.</p><p>Noting <code>k=length(x)</code> and <code>n=length(a)</code>, this algorithm takes <span>$O(n + k \log k)$</span> processing time to draw <span>$k$</span> elements. It consumes <span>$n$</span> random numbers.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/8f422bdcf0d1c4763372e35df7f1f310c7201a40/src/sampling.jl#L586-L596">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.efraimidis_ares_wsample_norep!" href="#StatsBase.efraimidis_ares_wsample_norep!"><code>StatsBase.efraimidis_ares_wsample_norep!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">efraimidis_ares_wsample_norep!([rng], a::AbstractArray, wv::AbstractWeights, x::AbstractArray)</code></pre><p>Implementation of weighted sampling without replacement using Efraimidis-Spirakis A-Res algorithm.</p><p>Reference: Efraimidis, P. S., Spirakis, P. G. &quot;Weighted random sampling with a reservoir.&quot; <em>Information Processing Letters</em>, 97 (5), 181-185, 2006. doi:10.1016/j.ipl.2005.11.003.</p><p>Noting <code>k=length(x)</code> and <code>n=length(a)</code>, this algorithm takes <span>$O(k \log(k) \log(n / k))$</span> processing time to draw <span>$k$</span> elements. It consumes <span>$n$</span> random numbers.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsBase.jl/blob/8f422bdcf0d1c4763372e35df7f1f310c7201a40/src/sampling.jl#L621-L631">source</a></section><footer><hr/><a class="previous" href="../ranking/"><span class="direction">Previous</span><span class="title">Rankings and Rank Correlations</span></a><a class="next" href="../empirical/"><span class="direction">Next</span><span class="title">Empirical Estimation</span></a></footer></article></body></html>
