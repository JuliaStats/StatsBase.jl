        - using Base.Cartesian
        - 
        - import Base: show, ==, push!, append!, float, norm, normalize, normalize!
        - 
        - # Mechanism for temporary deprecation of default for "closed" (because default
        - # value has changed). After deprecation is lifed, remove "_check_closed_arg"
        - # and all calls to it, and replace every ":default_left" with ":left". Also
        - # remove "closed=:left" in tests for all lines marked "FIXME: closed".
        - function _check_closed_arg(closed::Symbol, funcsym)
        0     if closed == :default_left
        0         Base.depwarn("Default for keyword argument \"closed\" has changed from :right to :left.\n" *
        -                      "To avoid this warning, specify closed=:right or closed=:left as appropriate.",
        -                      funcsym)
        0         :left
        -     else
        0         closed
        -     end
        - end
        - 
        - 
        - ## Fast getindex function for multiple arrays, returns a tuple of array elements
        - @inline Base.@propagate_inbounds @generated function _multi_getindex(i::Integer, c::AbstractArray...)
  8032139     N = length(c)
      112     result_expr = Expr(:tuple)
       64     for j in 1:N
      304         push!(result_expr.args, :(c[$j][i]))
        -     end
        0     result_expr
        - end
        - 
        - 
        - # Need a generated function to promote edge types, because a simple
        - # promote_type(map(eltype, h.edges)...) isn't type stable (tested
        - # with Julia v0.5).
        - @generated function _promote_edge_types{N}(edges::NTuple{N,AbstractVector})
        -     promote_type(map(eltype, edges.parameters)...)
        - end
        - 
        - 
        - ## nice-valued ranges for histograms
        - function histrange{T}(v::AbstractArray{T}, n::Integer, closed::Symbol=:default_left)
        0     closed = _check_closed_arg(closed,:histrange)
        -     F = float(T)
        0     nv = length(v)
        0     if nv == 0 && n < 0
        0         throw(ArgumentError("number of bins must be ≥ 0 for an empty array, got $n"))
        0     elseif nv > 0 && n < 1
        0         throw(ArgumentError("number of bins must be ≥ 1 for a non-empty array, got $n"))
        0     elseif nv == 0
        0         return zero(F):zero(F)
        -     end
        - 
        0     lo, hi = extrema(v)
        0     histrange(F(lo), F(hi), n, closed)
        - end
        - 
        - function histrange{F}(lo::F, hi::F, n::Integer, closed::Symbol=:default_left)
        0     closed = _check_closed_arg(closed,:histrange)
        0     if hi == lo
        0         start = F(hi)
        0         step = one(F)
        0         divisor = one(F)
        0         len = one(F)
        -     else
        0         bw = (F(hi) - F(lo)) / n
        0         lbw = log10(bw)
        0         if lbw >= 0
        0             step = exp10(floor(lbw))
        0             r = bw / step
        0             if r <= 1.1
        0                 nothing
        0             elseif r <= 2.2
        0                 step *= 2
        0             elseif r <= 5.5
        0                 step *= 5
        -             else
        0                 step *= 10
        -             end
        0             divisor = one(F)
        0             start = step*floor(lo/step)
        0             len = ceil((hi - start)/step)
        -         else
        0             divisor = exp10(-floor(lbw))
        0             r = bw * divisor
        0             if r <= 1.1
        0                 nothing
        0             elseif r <= 2.2
        0                 divisor /= 2
        0             elseif r <= 5.5
        0                 divisor /= 5
        -             else
        0                 divisor /= 10
        -             end
        0             step = one(F)
        0             start = floor(lo*divisor)
        0             len = ceil(hi*divisor - start)
        -         end
        -     end
        -     # fix up endpoints
        0     if closed == :right #(,]
        0         while lo <= start/divisor
        0             start -= step
        -         end
        0         while (start + (len-1)*step)/divisor < hi
        0             len += one(F)
        -         end
        -     else
        0         while lo < start/divisor
        0             start -= step
        -         end
        0         while (start + (len-1)*step)/divisor <= hi
        0             len += one(F)
        -         end
        -     end
        -     @static if VERSION < v"0.6.0-dev.2376" # Julia PR 18777
        -         FloatRange(start,step,len,divisor)
        -     else
        0         Base.floatrange(start,step,len,divisor)
        -     end
        - end
        - 
        0 histrange{N}(vs::NTuple{N,AbstractVector},nbins::NTuple{N,Integer},closed::Symbol) =
        -     map((v,n) -> histrange(v,n,closed),vs,nbins)
        - histrange{N}(vs::NTuple{N,AbstractVector},nbins::Integer,closed::Symbol) =
        -     map(v -> histrange(v,nbins,closed),vs)
        - 
        - 
        - 
        - ## histograms ##
        - function sturges(n)  # Sturges' formula
        0     n==0 && return one(n)
        0     ceil(Integer, log2(n))+1
        - end
        - 
        - @compat abstract type AbstractHistogram{T<:Real,N,E} end
        - 
        - # N-dimensional histogram object
        - type Histogram{T<:Real,N,E} <: AbstractHistogram{T,N,E}
        -     edges::E
        -     weights::Array{T,N}
        -     closed::Symbol
        -     isdensity::Bool
        -     function (::Type{Histogram{T,N,E}}){T,N,E}(edges::NTuple{N,AbstractArray},
        -                                                weights::Array{T,N}, closed::Symbol, isdensity::Bool=false)
        0         closed == :right || closed == :left || error("closed must :left or :right")
        0         isdensity && !(T <: AbstractFloat) && error("Density histogram must have float-type weights")
        0         _edges_nbins(edges) == size(weights) || error("Histogram edge vectors must be 1 longer than corresponding weight dimensions")
  1966080         new{T,N,E}(edges,weights,closed,isdensity)
        -     end
        - end
        - 
        0 Histogram{T,N}(edges::NTuple{N,AbstractVector},weights::AbstractArray{T,N},closed::Symbol=:default_left, isdensity::Bool=false) =
        -     Histogram{T,N,typeof(edges)}(edges,weights,_check_closed_arg(closed,:Histogram),isdensity)
        - 
  3932160 Histogram{T,N}(edges::NTuple{N,AbstractVector},::Type{T},closed::Symbol=:default_left, isdensity::Bool=false) =
        -     Histogram(edges,zeros(T,_edges_nbins(edges)...),_check_closed_arg(closed,:Histogram),isdensity)
        - 
        - Histogram{N}(edges::NTuple{N,AbstractVector},closed::Symbol=:default_left, isdensity::Bool=false) =
        -     Histogram(edges,Int,_check_closed_arg(closed,:Histogram),isdensity)
        - 
        - function show(io::IO, h::AbstractHistogram)
        -     println(io, typeof(h))
        -     println(io,"edges:")
        -     for e in h.edges
        -         println(io,"  ",e)
        -     end
        -     println(io,"weights: ",h.weights)
        -     println(io,"closed: ",h.closed)
        -     print(io,"isdensity: ",h.isdensity)
        - end
        - 
        - (==)(h1::Histogram,h2::Histogram) = (==)(h1.edges,h2.edges) && (==)(h1.weights,h2.weights) && (==)(h1.closed,h2.closed) && (==)(h1.isdensity,h2.isdensity)
        - 
        - 
        - binindex{T,E}(h::AbstractHistogram{T,1,E}, x::Real) = binindex(h, (x,))[1]
        - 
 26214400 binindex{T,N,E}(h::Histogram{T,N,E}, xs::NTuple{N,Real}) =
        0     map((edge, x) -> _edge_binindex(edge, h.closed, x), h.edges, xs)
        - 
        - @inline function _edge_binindex(edge::AbstractVector, closed::Symbol, x::Real)
        0     if closed == :right
        0         searchsortedfirst(edge, x) - 1
        -     else
        0         searchsortedlast(edge, x)
        -     end
        - end
        - 
        - 
        - binvolume{T,E}(h::AbstractHistogram{T,1,E}, binidx::Integer) = binvolume(h, (binidx,))
        - binvolume{V,T,E}(::Type{V}, h::AbstractHistogram{T,1,E}, binidx::Integer) = binvolume(V, h, (binidx,))
        - 
        - binvolume{T,N,E}(h::Histogram{T,N,E}, binidx::NTuple{N,Integer}) =
        -     binvolume(_promote_edge_types(h.edges), h, binidx)
        - 
        - binvolume{V,T,N,E}(::Type{V}, h::Histogram{T,N,E}, binidx::NTuple{N,Integer}) =
        -     prod(map((edge, i) -> _edge_binvolume(V, edge, i), h.edges, binidx))
        - 
        - @inline _edge_binvolume{V}(::Type{V}, edge::AbstractVector, i::Integer) = V(edge[i+1]) - V(edge[i])
        - @inline _edge_binvolume{V}(::Type{V}, edge::Range, i::Integer) = V(step(edge))
        - @inline _edge_binvolume(edge::AbstractVector, i::Integer) = _edge_binvolume(eltype(edge), edge, i)
        - 
        - 
        - @inline _edges_nbins{N}(edges::NTuple{N,AbstractVector}) = map(_edge_nbins, edges)
        - 
        - @inline _edge_nbins(edge::AbstractVector) = length(edge) - 1
        - 
        - 
        - # 1-dimensional
        - 
        - Histogram{T}(edge::AbstractVector, weights::AbstractVector{T}, closed::Symbol=:default_left, isdensity::Bool=false) =
        -     Histogram((edge,), weights, closed, isdensity)
        - 
        - Histogram{T}(edge::AbstractVector, ::Type{T}, closed::Symbol=:default_left, isdensity::Bool=false) =
        -     Histogram((edge,), T, closed, isdensity)
        - 
        - Histogram(edge::AbstractVector, closed::Symbol=:default_left, isdensity::Bool=false) =
        -     Histogram((edge,), closed, isdensity)
        - 
        - 
        - push!{T,E}(h::AbstractHistogram{T,1,E}, x::Real, w::Real) = push!(h, (x,), w)
        - push!{T,E}(h::AbstractHistogram{T,1,E}, x::Real) = push!(h,x,one(T))
        - append!{T}(h::AbstractHistogram{T,1}, v::AbstractVector) = append!(h, (v,))
        - append!{T}(h::AbstractHistogram{T,1}, v::AbstractVector, wv::Union{AbstractVector,AbstractWeights}) = append!(h, (v,), wv)
        - 
        - fit{T}(::Type{Histogram{T}},v::AbstractVector, edg::AbstractVector; closed::Symbol=:default_left) =
        -     fit(Histogram{T},(v,), (edg,), closed=closed)
        - fit{T}(::Type{Histogram{T}},v::AbstractVector; closed::Symbol=:default_left, nbins=sturges(length(v))) =
        -     fit(Histogram{T},(v,); closed=closed, nbins=nbins)
        - fit{T}(::Type{Histogram{T}},v::AbstractVector, wv::AbstractWeights, edg::AbstractVector; closed::Symbol=:default_left) =
        -     fit(Histogram{T},(v,), wv, (edg,), closed=closed)
        - fit{T}(::Type{Histogram{T}},v::AbstractVector, wv::AbstractWeights; closed::Symbol=:default_left, nbins=sturges(length(v))) =
        -     fit(Histogram{T}, (v,), wv; closed=closed, nbins=nbins)
        - 
        - fit{W}(::Type{Histogram}, v::AbstractVector, wv::AbstractWeights{W}, args...; kwargs...) = fit(Histogram{W}, v, wv, args...; kwargs...)
        - 
        - # N-dimensional
        - 
        - function push!{T,N}(h::Histogram{T,N},xs::NTuple{N,Real},w::Real)
        0     h.isdensity && error("Density histogram must have float-type weights")
        0     idx = binindex(h, xs)
        0     if checkbounds(Bool, h.weights, idx...)
        0         @inbounds h.weights[idx...] += w
        -     end
        0     h
        - end
        - 
        - function push!{T<:AbstractFloat,N}(h::Histogram{T,N},xs::NTuple{N,Real},w::Real)
        -     idx = binindex(h, xs)
        -     if checkbounds(Bool, h.weights, idx...)
        -         @inbounds h.weights[idx...] += h.isdensity ? w / binvolume(h, idx) : w
        -     end
        -     h
        - end
        - 
        - push!{T,N}(h::AbstractHistogram{T,N},xs::NTuple{N,Real}) = push!(h,xs,one(T))
        - 
        - 
        - function append!{T,N}(h::AbstractHistogram{T,N}, vs::NTuple{N,AbstractVector})
        0     @inbounds for i in eachindex(vs...)
        0         xs = _multi_getindex(i, vs...)
        0         push!(h, xs, one(T))
        -     end
        0     h
        - end
        - function append!{T,N}(h::AbstractHistogram{T,N}, vs::NTuple{N,AbstractVector}, wv::AbstractVector)
        -     @inbounds for i in eachindex(wv, vs...)
        -         xs = _multi_getindex(i, vs...)
        -         push!(h, xs, wv[i])
        -     end
        -     h
        - end
        - append!{T,N}(h::AbstractHistogram{T,N}, vs::NTuple{N,AbstractVector}, wv::AbstractWeights) = append!(h, vs, values(wv))
        - 
        - 
        - # Turn kwargs nbins into a type-stable tuple of integers:
        - function _nbins_tuple{N}(vs::NTuple{N,AbstractVector}, nbins)
        0     template = map(length, vs)
        - 
        -     @static if VERSION < v"0.6.0-dev.695"
        -         result = if isa(nbins, Integer)
        -             map(t -> typeof(t)(nbins), template)
        -         elseif isa(nbins, NTuple{N, Integer})
        -             map((t, x) -> typeof(t)(x), template, nbins)
        -         else
        -             throw(ArgumentError("nbins must be an Integer or NTuple{N, Integer}"))
        -         end
        -     else
        0         result = broadcast((t, x) -> typeof(t)(x), template, nbins)
        -     end
        - 
        -     result::typeof(template)
        - end
        - 
  7709413 fit{T,N}(::Type{Histogram{T}}, vs::NTuple{N,AbstractVector}, edges::NTuple{N,AbstractVector}; closed::Symbol=:default_left) =
        -     append!(Histogram(edges, T, _check_closed_arg(closed,:fit), false), vs)
        - 
        - fit{T,N}(::Type{Histogram{T}}, vs::NTuple{N,AbstractVector}; closed::Symbol=:default_left, nbins=sturges(length(vs[1]))) = begin
  3499712     closed = _check_closed_arg(closed,:fit)
   786432     fit(Histogram{T}, vs, histrange(vs,_nbins_tuple(vs, nbins),closed); closed=closed)
        - end
        - 
        - fit{T,N,W}(::Type{Histogram{T}}, vs::NTuple{N,AbstractVector}, wv::AbstractWeights{W}, edges::NTuple{N,AbstractVector}; closed::Symbol=:default_left) =
        -     append!(Histogram(edges, T, _check_closed_arg(closed,:fit), false), vs, wv)
        - 
        - fit{T,N}(::Type{Histogram{T}}, vs::NTuple{N,AbstractVector}, wv::AbstractWeights; closed::Symbol=:default_left, nbins=sturges(length(vs[1]))) = begin
        -     closed = _check_closed_arg(closed,:fit)
        -     fit(Histogram{T}, vs, wv, histrange(vs,_nbins_tuple(vs, nbins),closed); closed=closed)
        - end
        - 
        - """
        -     fit(Histogram, data[, weight][, edges]; closed=:right, nbins)
        - 
        - Fit a histogram to `data`.
        - 
        - # Arguments
        - 
        - * `data`: either a vector (for a 1-dimensional histogram), or a tuple of
        -   vectors of equal length (for an *n*-dimensional histogram).
        - 
        - * `weight`: an optional `AbstractWeights` (of the same length as the
        -   data vectors), denoting the weight each observation contributes to the
        -   bin. If no weight vector is supplied, each observation has weight 1.
        - 
        - * `edges`: a vector (typically a `Range` object), or tuple of vectors, that gives
        -   the edges of the bins along each dimension. If no edges are provided, these
        -   are determined from the data.
        - 
        - # Keyword arguments
        - 
        - * `closed=:right`: if `:left`, the bin intervals are left-closed [a,b);
        -   if `:right` (the default), intervals are right-closed (a,b].
        - 
        - * `nbins`: if no `edges` argument is supplied, the approximate number of bins to use
        -   along each dimension (can be either a single integer, or a tuple of integers).
        - 
        - # Examples
        - 
        - ```julia
        - # Univariate
        - h = fit(Histogram, rand(100))
        - h = fit(Histogram, rand(100), 0:0.1:1.0)
        - h = fit(Histogram, rand(100), nbins=10)
        - h = fit(Histogram, rand(100), weights(rand(100)), 0:0.1:1.0)
        - h = fit(Histogram, [20], 0:20:100)
        - h = fit(Histogram, [20], 0:20:100, closed=:left)
        - 
        - # Multivariate
        - h = fit(Histogram, (rand(100),rand(100)))
        - h = fit(Histogram, (rand(100),rand(100)),nbins=10)
        - ```
        - """
 20849144 fit(::Type{Histogram}, args...; kwargs...) = fit(Histogram{Int}, args...; kwargs...)
        - fit{N,W}(::Type{Histogram}, vs::NTuple{N,AbstractVector}, wv::AbstractWeights{W}, args...; kwargs...) = fit(Histogram{W}, vs, wv, args...; kwargs...)
        - 
        - 
        - # Get a suitable high-precision type for the norm of a histogram.
        - norm_type{T, N, E}(h::Histogram{T, N, E}) =
        -     promote_type(T, _promote_edge_types(h.edges))
        - 
        - norm_type{T<:Integer}(::Type{T}) = promote_type(T, Int64)
        - norm_type{T<:AbstractFloat}(::Type{T}) = promote_type(T, Float64)
        - 
        - 
        - """
        -     norm(h::Histogram)
        - 
        - Calculate the norm of histogram `h` as the absolute value of its integral.
        - """
        - @generated function norm{T, N, E}(h::Histogram{T, N, E})
        -     quote
        -         edges = h.edges
        -         weights = h.weights
        -         SumT = norm_type(h)
        -         v_0 = 1
        -         s_0 = zero(SumT)
        -         @inbounds @nloops(
        -             $N, i, weights,
        -             d -> begin
        -                 v_{$N-d+1} = v_{$N-d} * _edge_binvolume(SumT, edges[d], i_d)
        -                 s_{$N-d+1} = zero(SumT)
        -             end,
        -             d -> begin
        -                 s_{$N-d} += s_{$N-d+1}
        -             end,
        -             begin
        -                 $(Symbol("s_$(N)")) += (@nref $N weights i) * $(Symbol("v_$N"))
        -             end
        -         )
        -         s_0
        -     end
        - end
        - 
        - 
        - float{T<:AbstractFloat, N, E}(h::Histogram{T, N, E}) = h
        - 
        - float{T, N, E}(h::Histogram{T, N, E}) = Histogram(h.edges, float(h.weights), h.closed, h.isdensity)
        - 
        - 
        - 
        - """
        -     normalize!{T<:AbstractFloat, N, E}(h::Histogram{T, N, E}, aux_weights::Array{T,N}...; mode::Symbol = :pdf)
        - 
        - Normalize the histogram `h` and optionally scale one or more auxiliary weight
        - arrays appropriately. See description of `normalize` for details. Returns `h`.
        - """
        - @generated function normalize!{T<:AbstractFloat, N, E}(h::Histogram{T, N, E}, aux_weights::Array{T,N}...; mode::Symbol = :pdf)
        -     quote
        -         edges = h.edges
        -         weights = h.weights
        - 
        -         for A in aux_weights
        -             (size(A) != size(weights)) && throw(DimensionMismatch("aux_weights must have same size as histogram weights"))
        -         end
        - 
        -         if mode == :none
        -             # nothing to do
        -         elseif mode == :pdf || mode == :density
        -             if h.isdensity
        -                 if mode == :pdf
        -                     # histogram already represents a density, just divide weights by norm
        -                     s = 1/norm(h)
        -                     weights .*= s
        -                     for A in aux_weights
        -                         A .*= s
        -                     end
        -                 else
        -                     # histogram already represents a density, nothing to do
        -                 end
        -             else
        -                 # Divide weights by bin volume, for :pdf also divide by sum of weights
        -                 SumT = norm_type(h)
        -                 vs_0 = (mode == :pdf) ? sum(SumT(x) for x in weights) : one(SumT)
        -                 @inbounds @nloops $N i weights d->(vs_{$N-d+1} = vs_{$N-d} * _edge_binvolume(SumT, edges[d], i_d)) begin
        -                     (@nref $N weights i) /= $(Symbol("vs_$N"))
        -                     for A in aux_weights
        -                         (@nref $N A i) /= $(Symbol("vs_$N"))
        -                     end
        -                 end
        -             end
        -             h.isdensity = true
        -         else mode != :pdf && mode != :density
        -             throw(ArgumentError("Normalization mode must be :pdf, :density or :none"))
        -         end
        -         h
        -     end
        - end
        - 
        - 
        - """
        -     normalize{T, N, E}(h::Histogram{T, N, E}; mode::Symbol = :pdf)
        - 
        - Normalize the histogram `h`.
        - 
        - Valid values for `mode` are:
        - 
        - *  `:pdf`: Normalize by sum of weights and bin sizes. Resulting histogram
        -    has norm 1 and represents a PDF.
        - * `:density`: Normalize by bin sizes only. Resulting histogram represents
        -    count density of input and does not have norm 1. Will not modify the
        -    histogram if it already represents a density (`h.isdensity == 1`).
        - *  `:none`: Leaves histogram unchanged. Useful to simplify code that has to
        -    conditionally apply different modes of normalization.
        - """
        - normalize{T, N, E}(h::Histogram{T, N, E}; mode::Symbol = :pdf) =
        -     normalize!(deepcopy(float(h)), mode = mode)
        - 
        - 
        - """
        -     normalize{T, N, E}(h::Histogram{T, N, E}, aux_weights::Array{T,N}...; mode::Symbol = :pdf)
        - 
        - Normalize the histogram `h` and rescales one or more auxiliary weight arrays
        - at the same time (`aux_weights` may, e.g., contain estimated statistical
        - uncertainties). The values of the auxiliary arrays are scaled by the same
        - factor as the corresponding histogram weight values. Returns a tuple of the
        - normalized histogram and scaled auxiliary weights.
        - """
        - function normalize{T, N, E}(h::Histogram{T, N, E}, aux_weights::Array{T,N}...; mode::Symbol = :pdf)
        -     h_fltcp = deepcopy(float(h))
        -     aux_weights_fltcp = map(x -> deepcopy(float(x)), aux_weights)
        -     normalize!(h_fltcp, aux_weights_fltcp..., mode = mode)
        -     (h_fltcp, aux_weights_fltcp...)
        - end
        - 
        - 
        - """
        -     zero(h::Histogram)
        - 
        - Create a new histogram with the same binning, type and shape of weights
        - and the same properties (`closed` and `isdensity`) as `h`, with all weights
        - set to zero.
        - """
        - Base.zero{T,N,E}(h::Histogram{T,N,E}) =
        -     Histogram{T,N,E}(deepcopy(h.edges), zero(h.weights), h.closed, h.isdensity)
        - 
        - 
        - """
        -     merge!(target::Histogram, others::Histogram...)
        - 
        - Update histogram `target` by merging it with the histograms `others`. See
        - `merge(histogram::Histogram, others::Histogram...)` for details.
        - """
        - function Base.merge!(target::Histogram, others::Histogram...)
        -     for h in others
        -         target.edges != h.edges && throw(ArgumentError("can't merge histograms with different binning"))
        -         size(target.weights) != size(h.weights) && throw(ArgumentError("can't merge histograms with different dimensions"))
        -         target.closed != h.closed && throw(ArgumentError("can't merge histograms with different closed left/right settings"))
        -         target.isdensity != h.isdensity && throw(ArgumentError("can't merge histograms with different isdensity settings"))
        -     end
        -     for h in others
        -         target.weights .+= h.weights
        -     end
        -     target
        - end
        - 
        - 
        - """
        -     merge(h::Histogram, others::Histogram...)
        - 
        - Construct a new histogram by merging `h` with `others`. All histograms must
        - have the same binning, shape of weights and properties (`closed` and
        - `isdensity`). The weights of all histograms are summed up for each bin, the
        - weights of the resulting histogram will have the same type as those of `h`.
        - """
        - Base.merge(h::Histogram, others::Histogram...) = merge!(zero(h), h, others...)
        - 
